<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Examen - Gr√°ficas por Computadora</title>
</head>
<body>
    <canvas id="canvas" width="800" height="800"></canvas>

    <script>
        var canvas = document.getElementById('canvas');
        var gl = canvas.getContext('webgl');

        /* function Cylinder() {
            var sides = 20;
            var height = 0.5;
            var stepTheta = 2 * Math.PI / sides;
            var verticesPerCap = 9 * sides;

            var vertices = [];
            var theta = 0;
            var i = 0;

            // Top Cap
            for (; i < verticesPerCap; i += 9) {
                vertices[i] = Math.cos(theta);
                vertices[i + 1] = Math.sin(theta);
                vertices[i + 2] = height;
                theta += stepTheta;

                vertices[i + 3] = 0.0;
                vertices[i + 4] = 0.0;
                vertices[i + 5] = height;

                vertices[i + 6] = Math.cos(theta);
                vertices[i + 7] = Math.sin(theta);
                vertices[i + 8] = height;
            }

            // Bottom Cap
            theta = 0;
            for (; i < verticesPerCap + verticesPerCap; i += 9) {
                vertices[i + 6] = Math.cos(theta);
                vertices[i + 7] = Math.sin(theta);
                vertices[i + 8] = -height;
                theta += stepTheta;

                vertices[i + 3] = 0.0;
                vertices[i + 4] = 0.0;
                vertices[i + 5] = -height;

                vertices[i] = Math.cos(theta);
                vertices[i + 1] = Math.sin(theta);
                vertices[i + 2] = -height;
            }

            for (var j = 0; j < sides; ++j) {
                for (var k = 0; k < 3; ++k, ++i) {
                    vertices[i] = vertices[0 + k + 9 * j];
                }
                for (var k = 0; k < 3; ++k, ++i) {
                    vertices[i] = vertices[6 + k + 9 * j];
                }
                for (var k = 0; k < 3; ++k, ++i) {
                    vertices[i] = vertices[verticesPerCap + k + 9 * j];
                }

                for (var k = 0; k < 3; ++k, ++i) {
                    vertices[i] = vertices[0 + k + 9 * j];
                }
                for (var k = 0; k < 3; ++k, ++i) {
                    vertices[i] = vertices[verticesPerCap + k + 9 * j];
                }
                for (var k = 0; k < 3; ++k, ++i) {
                    vertices[i] = vertices[verticesPerCap + 6 + k + 9 * j];
                }
            }

            var indices = new Array(vertices.length / 3);
            for (i = 0; i < indices.length; ++i) indices[i] = i;

            function sub(a, b) { return [a[0] - b[0], a[1] - b[1], a[2] - b[2]]; };
            function cross(a, b) {
                return [
                    a[1] * b[2] - a[2] * b[1],
                    a[2] * b[0] - a[0] * b[2],
                    a[0] * b[1] - a[1] * b[0]
                ];
            };

            return {
                vertices: vertices,
                indices: indices,
            };
        } */

        function Cylinder() {
            var sides = 20;
            var height = 1.0;
            var stepTheta = 2 * Math.PI / sides;
            var verticesPerCap = 9 * sides;

            var vertices = [];
            var theta = 0;
            var i = 0;

            // Top Cap
            for (; i < verticesPerCap; i += 9) {
                vertices[i] = Math.cos(theta);
                vertices[i + 1] = height;
                vertices[i + 2] = Math.sin(theta);
                theta += stepTheta;

                vertices[i + 3] = 0.0;
                vertices[i + 4] = height;
                vertices[i + 5] = 0.0;

                vertices[i + 6] = Math.cos(theta);
                vertices[i + 7] = height;
                vertices[i + 8] = Math.sin(theta);
            }

            // Bottom Cap
            theta = 0;
            for (; i < verticesPerCap + verticesPerCap; i += 9) {
                vertices[i + 6] = Math.cos(theta);
                vertices[i + 7] = -height;
                vertices[i + 8] = Math.sin(theta);
                theta += stepTheta;

                vertices[i + 3] = 0.0;
                vertices[i + 4] = -height;
                vertices[i + 5] = 0.0;

                vertices[i] = Math.cos(theta);
                vertices[i + 1] = -height;
                vertices[i + 2] = Math.sin(theta);
            }

            for (var j = 0; j < sides; ++j) {
                for (var k = 0; k < 3; ++k, ++i) {
                    vertices[i] = vertices[0 + k + 9 * j];
                }
                for (var k = 0; k < 3; ++k, ++i) {
                    vertices[i] = vertices[6 + k + 9 * j];
                }
                for (var k = 0; k < 3; ++k, ++i) {
                    vertices[i] = vertices[verticesPerCap + k + 9 * j];
                }

                for (var k = 0; k < 3; ++k, ++i) {
                    vertices[i] = vertices[0 + k + 9 * j];
                }
                for (var k = 0; k < 3; ++k, ++i) {
                    vertices[i] = vertices[verticesPerCap + k + 9 * j];
                }
                for (var k = 0; k < 3; ++k, ++i) {
                    vertices[i] = vertices[verticesPerCap + 6 + k + 9 * j];
                }
            }

            var indices = new Array(vertices.length / 3);
            for (i = 0; i < indices.length; ++i) indices[i] = i;

            function sub(a, b) { return [a[0] - b[0], a[1] - b[1], a[2] - b[2]]; };
            function cross(a, b) {
                return [
                    a[1] * b[2] - a[2] * b[1],
                    a[2] * b[0] - a[0] * b[2],
                    a[0] * b[1] - a[1] * b[0]
                ];
            };

            return {
                vertices: vertices,
                indices: indices,
            };
        };

        var cylindre = Cylinder();
        var vertices = cylindre.vertices;
        var indices = cylindre.indices;

        var colors = [];
        for (let i = 0; i<vertices.length; i ++) {
            colors[i] = Math.random();
        }

        // Vertex buffer
        var vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        // Index buffer
        var indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        // Color buffer
        var colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        // Shaders
        var vertCode = `
            attribute vec3 position;
            attribute vec3 color;
            uniform mat4 Pmatrix;
            uniform mat4 Vmatrix;
            uniform mat4 Mmatrix;
            varying vec3 vColor;
            void main(void) {
                gl_Position = Pmatrix * Vmatrix * Mmatrix * vec4(position, 1.0);
                vColor = color;
            }
        `;

        var fragCode = `
            precision mediump float;
            varying vec3 vColor;
            void main(void) {
                gl_FragColor = vec4(vColor, 1.0);
            }
        `;

        // Compilar y vincular el programa shader
        var program = gl.createProgram();

        var vertShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertShader, vertCode);
        gl.compileShader(vertShader);

        var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragShader, fragCode);
        gl.compileShader(fragShader);

        gl.attachShader(program, vertShader);
        gl.attachShader(program, fragShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // Vincular buffers y atributos
        var Mmatrix = gl.getUniformLocation(program, 'Mmatrix');
        var Vmatrix = gl.getUniformLocation(program, 'Vmatrix');
        var Pmatrix = gl.getUniformLocation(program, 'Pmatrix');

        var position = gl.getAttribLocation(program, 'position');
        var color = gl.getAttribLocation(program, 'color');

        gl.enableVertexAttribArray(position);
        gl.enableVertexAttribArray(color);

        function get_projection(angle, a, zMin, zMax) {
            var ang = Math.tan((angle * .5) * Math.PI / 180);
            return [
                0.5 / ang, 0, 0, 0,
                0, 0.5 * a / ang, 0, 0,
                0, 0, -(zMax + zMin) / (zMax - zMin), -1,
                0, 0, (-2 * zMax * zMin) / (zMax - zMin), 0
            ];
        }

        projMatrix = get_projection(40, canvas.width / canvas.height, 1, 100);

        viewMatrix = [
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, -15, 1
        ];

        movMatrix = [
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ];

        // Movimientos
        function tangentCircleRoll(m, angle, radius, rollAngle) {
            let x = radius * Math.cos(angle);
            let y = radius * Math.sin(angle);

            let tx = -Math.sin(angle);
            let ty = Math.cos(angle);

            let c = Math.cos(rollAngle);
            let s = Math.sin(rollAngle);

            m[0] = tx * c - 0 * s;    m[4] = -ty;      m[8]  = tx * s + 0 * c;   m[12] = x;
            m[1] = ty * c - 0 * s;    m[5] = tx;       m[9]  = ty * s + 0 * c;   m[13] = y;
            m[2] = 0 * c - 1 * s;     m[6] = 0;        m[10] = 0 * s + 1 * c;    m[14] = 0;
            m[3] = 0;                  m[7] = 0;        m[11] = 0;                m[15] = 1;
        }

        function circle(m, angle, radius) {
            var x = radius * Math.cos(angle);
            var y = radius * Math.sin(angle);

            m[12] = x;
            m[13] = y;
            m[14] = 0;
        }

        function rotateY(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv0 = m[0], mv4 = m[4], mv8 = m[8];

            m[0] = c * m[0] + s * m[2];
            m[4] = c * m[4] + s * m[6];
            m[8] = c * m[8] + s * m[10];

            m[2] = c * m[2] - s * mv0;
            m[6] = c * m[6] - s * mv4;
            m[10] = c * m[10] - s * mv8;
        }

        function rotateZ(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv0 = m[0], mv4 = m[4], mv8 = m[8];

            m[0] = c * m[0] - s * m[1];
            m[4] = c * m[4] - s * m[5];
            m[8] = c * m[8] - s * m[9];

            m[1] = c * m[1] + s * mv0;
            m[5] = c * m[5] + s * mv4;
            m[9] = c * m[9] + s * mv8;
        }

        // Dibujar escena
        var timeOld = 0;
        var animate = function (time) {

            var dt = time - timeOld;

            //rotateY(movMatrix, dt * 0.002);
            //rotateZ(movMatrix, dt * 0.001);

            //circle(movMatrix, time * 0.001, 6);

            tangentCircleRoll(movMatrix, time * 0.001, 6, 0.002 * time);

            timeOld = time;

            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            gl.clearColor(0.5, 0.5, 0.5, 0.9);
            gl.clearDepth(1.0);
            gl.viewport(0.0, 0.0, canvas.width, canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.uniformMatrix4fv(Pmatrix, false, new Float32Array(projMatrix));
            gl.uniformMatrix4fv(Vmatrix, false, new Float32Array(viewMatrix));
            gl.uniformMatrix4fv(Mmatrix, false, new Float32Array(movMatrix));

            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.vertexAttribPointer(position, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.vertexAttribPointer(color, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

            window.requestAnimationFrame(animate);
        };
        animate(0);
    </script>
</body>
</html>