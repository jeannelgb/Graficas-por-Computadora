<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Examen - Gráficas por Computadora</title>
    <style>
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            display: inline-block;
        }
        #controls div {
            display: flex;
            justify-content: center;
        }
        .smallButton {
            width: 50px;
            height: 50px;
            margin: 3px;
            font-size: 18px;
            cursor: pointer;
            background-color: rgba(255, 255, 255, 0.5);
            border: none;
            border-radius: 10px;
        }
        button:hover {
            background-color: rgba(255, 255, 255, 0.8);
        }
        .reset {
            width: 156px;
            height: 50px;
            margin: 3px;
            font-size: 18px;
            cursor: pointer;
            background-color: rgba(255, 255, 255, 0.5);
            border: none;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="800"></canvas>
    <div id="controls">
        <div>
            <button class="smallButton" onclick="zoomIn()">+</button>
            <button class="smallButton" onclick="up()">↑</button>
            <button class="smallButton" onclick="zoomOut()">-</button>
        </div>
        <div>
            <button class="smallButton" onclick="left()">←</button>
            <button class="smallButton" onclick="down()">↓</button>
            <button class="smallButton" onclick="right()">→</button>
        </div>
        <div>
            <button class="reset"onclick="reset()">Reset</button>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix.js"></script>
    <script>
        var canvas = document.getElementById('canvas');
        var gl = canvas.getContext('webgl');

        var radius = 20;
        var theta = Math.PI / 2;
        var phi = 0.0;

        function up() {
            phi += 0.1;
            if (phi > Math.PI / 2) phi = Math.PI / 2;
        }

        function down() {
            phi -= 0.1;
            if (phi < -Math.PI / 2) phi = -Math.PI / 2;
        }

        function left() {
            theta -= 0.1;
            if (theta < 0) theta += 2 * Math.PI;
        }

        function right() {
            theta += 0.1;
            if (theta > 2 * Math.PI) theta -= 2 * Math.PI;
        }

        function zoomIn() {
            radius -= 0.5;
        }

        function zoomOut() {
            radius += 0.5;
        }

        function reset() {
            radius = 20;
            theta = Math.PI / 2;
            phi = 0.0;
        }

        function Cylinder() {
            var sides = 20;
            var height = 1.0;
            var stepTheta = 2 * Math.PI / sides;
            var verticesPerCap = 9 * sides;

            var vertices = [];
            var theta = 0;
            var i = 0;

            // Top Cap
            for (; i < verticesPerCap; i += 9) {
                vertices[i] = Math.cos(theta);
                vertices[i + 1] = height;
                vertices[i + 2] = Math.sin(theta);
                theta += stepTheta;

                vertices[i + 3] = 0.0;
                vertices[i + 4] = height;
                vertices[i + 5] = 0.0;

                vertices[i + 6] = Math.cos(theta);
                vertices[i + 7] = height;
                vertices[i + 8] = Math.sin(theta);
            }

            // Bottom Cap
            theta = 0;
            for (; i < verticesPerCap + verticesPerCap; i += 9) {
                vertices[i + 6] = Math.cos(theta);
                vertices[i + 7] = -height;
                vertices[i + 8] = Math.sin(theta);
                theta += stepTheta;

                vertices[i + 3] = 0.0;
                vertices[i + 4] = -height;
                vertices[i + 5] = 0.0;

                vertices[i] = Math.cos(theta);
                vertices[i + 1] = -height;
                vertices[i + 2] = Math.sin(theta);
            }

            for (var j = 0; j < sides; ++j) {
                for (var k = 0; k < 3; ++k, ++i) {
                    vertices[i] = vertices[0 + k + 9 * j];
                }
                for (var k = 0; k < 3; ++k, ++i) {
                    vertices[i] = vertices[6 + k + 9 * j];
                }
                for (var k = 0; k < 3; ++k, ++i) {
                    vertices[i] = vertices[verticesPerCap + k + 9 * j];
                }

                for (var k = 0; k < 3; ++k, ++i) {
                    vertices[i] = vertices[0 + k + 9 * j];
                }
                for (var k = 0; k < 3; ++k, ++i) {
                    vertices[i] = vertices[verticesPerCap + k + 9 * j];
                }
                for (var k = 0; k < 3; ++k, ++i) {
                    vertices[i] = vertices[verticesPerCap + 6 + k + 9 * j];
                }
            }

            var indices = new Array(vertices.length / 3);
            for (i = 0; i < indices.length; ++i) indices[i] = i;

            function sub(a, b) { return [a[0] - b[0], a[1] - b[1], a[2] - b[2]]; };
            function cross(a, b) {
                return [
                    a[1] * b[2] - a[2] * b[1],
                    a[2] * b[0] - a[0] * b[2],
                    a[0] * b[1] - a[1] * b[0]
                ];
            };

            return {
                vertices: vertices,
                indices: indices,
            };
        };

        var cylindre = Cylinder();
        var vertices = cylindre.vertices;
        var indices = cylindre.indices;

        var colors = [];
        for (let i = 0; i<vertices.length; i ++) {
            colors[i] = Math.random();
        }

        // Vertex buffer
        var vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        // Index buffer
        var indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        // Color buffer
        var colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        // Shaders
        var vertCode = `
            attribute vec3 position;
            attribute vec3 color;
            uniform mat4 Pmatrix;
            uniform mat4 MVmatrix;
            varying vec3 vColor;
            void main(void) {
                gl_Position = Pmatrix * MVmatrix * vec4(position, 1.0);
                vColor = color;
            }
        `;

        var fragCode = `
            precision mediump float;
            varying vec3 vColor;
            void main(void) {
                gl_FragColor = vec4(vColor, 1.0);
            }
        `;

        // Compilar y vincular el programa shader
        var program = gl.createProgram();

        var vertShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertShader, vertCode);
        gl.compileShader(vertShader);

        var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragShader, fragCode);
        gl.compileShader(fragShader);

        gl.attachShader(program, vertShader);
        gl.attachShader(program, fragShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // Vincular buffers y atributos
        var MVmatrix = gl.getUniformLocation(program, 'MVmatrix');
        var Pmatrix = gl.getUniformLocation(program, 'Pmatrix');

        var position = gl.getAttribLocation(program, 'position');
        var color = gl.getAttribLocation(program, 'color');

        gl.enableVertexAttribArray(position);
        gl.enableVertexAttribArray(color);

        // Dibujar escena
        var timeOld = 0;
        var animate = function (time) {
            var dt = time - timeOld;
            timeOld = time;

            var projMatrix = mat4.create();
            mat4.perspective(projMatrix, 40 * Math.PI / 180, canvas.width / canvas.height, 1, 100);
            gl.uniformMatrix4fv(Pmatrix, false, projMatrix);

            var eye = [
                radius * Math.cos(theta) * Math.cos(phi),
                radius * Math.sin(phi),
                radius * Math.sin(theta) * Math.cos(phi)
            ];

            var viewMatrix = mat4.create();
            mat4.lookAt(viewMatrix, eye, [0, 0, 0], [0, 1, 0]);

            var modelViewMatrix = mat4.clone(viewMatrix);
            mat4.translate(modelViewMatrix, modelViewMatrix, [
                4 * Math.cos(0.001*time),
                4 * Math.sin(0.001*time),
                0
            ]);
            mat4.rotateZ(modelViewMatrix, modelViewMatrix, 0.001*time + Math.PI / 2);
            mat4.rotateY(modelViewMatrix, modelViewMatrix, 4*0.001*time);

            gl.uniformMatrix4fv(MVmatrix, false, modelViewMatrix);

            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            gl.clearColor(0.5, 0.5, 0.5, 0.9);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.vertexAttribPointer(position, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(position);

            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.vertexAttribPointer(color, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(color);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

            window.requestAnimationFrame(animate);
        };

        // Controles de teclado
        document.addEventListener("keydown", function(event) {
            switch (event.key) {
                case "ArrowUp":    up(); break;
                case "ArrowDown":  down(); break;
                case "ArrowLeft":  left(); break;
                case "ArrowRight": right(); break;
                case "+":          zoomIn(); break;
                case "-":          zoomOut(); break;
            }
        });
        animate(0);
    </script>
</body>
</html>